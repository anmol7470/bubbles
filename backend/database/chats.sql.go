// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: chats.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const addChatMember = `-- name: AddChatMember :exec
INSERT INTO chat_members (chat_id, user_id)
VALUES ($1, $2)
`

type AddChatMemberParams struct {
	ChatID uuid.UUID `json:"chat_id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) AddChatMember(ctx context.Context, arg AddChatMemberParams) error {
	_, err := q.db.ExecContext(ctx, addChatMember, arg.ChatID, arg.UserID)
	return err
}

const createChat = `-- name: CreateChat :one
INSERT INTO chats (name, is_group, created_by)
VALUES ($1, $2, $3)
RETURNING id, name, is_group, created_at, updated_at, created_by
`

type CreateChatParams struct {
	Name      sql.NullString `json:"name"`
	IsGroup   bool           `json:"is_group"`
	CreatedBy uuid.UUID      `json:"created_by"`
}

func (q *Queries) CreateChat(ctx context.Context, arg CreateChatParams) (Chat, error) {
	row := q.db.QueryRowContext(ctx, createChat, arg.Name, arg.IsGroup, arg.CreatedBy)
	var i Chat
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.IsGroup,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
	)
	return i, err
}

const deleteChat = `-- name: DeleteChat :exec
DELETE FROM chats
WHERE id = $1
`

func (q *Queries) DeleteChat(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteChat, id)
	return err
}

const getChatByIdWithMembers = `-- name: GetChatByIdWithMembers :many
SELECT
    c.id as chat_id,
    c.name as chat_name,
    c.is_group,
    c.created_by,
    c.created_at as chat_created_at,
    c.updated_at as chat_updated_at,
    u.id as member_id,
    u.username as member_username,
    u.email as member_email,
    u.profile_image_url as member_profile_image_url
FROM chats c
INNER JOIN chat_members cm ON c.id = cm.chat_id
INNER JOIN users u ON cm.user_id = u.id
WHERE c.id = $1
ORDER BY u.username ASC
`

type GetChatByIdWithMembersRow struct {
	ChatID                uuid.UUID      `json:"chat_id"`
	ChatName              sql.NullString `json:"chat_name"`
	IsGroup               bool           `json:"is_group"`
	CreatedBy             uuid.UUID      `json:"created_by"`
	ChatCreatedAt         time.Time      `json:"chat_created_at"`
	ChatUpdatedAt         time.Time      `json:"chat_updated_at"`
	MemberID              uuid.UUID      `json:"member_id"`
	MemberUsername        string         `json:"member_username"`
	MemberEmail           string         `json:"member_email"`
	MemberProfileImageUrl sql.NullString `json:"member_profile_image_url"`
}

func (q *Queries) GetChatByIdWithMembers(ctx context.Context, id uuid.UUID) ([]GetChatByIdWithMembersRow, error) {
	rows, err := q.db.QueryContext(ctx, getChatByIdWithMembers, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetChatByIdWithMembersRow{}
	for rows.Next() {
		var i GetChatByIdWithMembersRow
		if err := rows.Scan(
			&i.ChatID,
			&i.ChatName,
			&i.IsGroup,
			&i.CreatedBy,
			&i.ChatCreatedAt,
			&i.ChatUpdatedAt,
			&i.MemberID,
			&i.MemberUsername,
			&i.MemberEmail,
			&i.MemberProfileImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChatByMembers = `-- name: GetChatByMembers :one
SELECT c.id, c.name, c.is_group, c.created_by, c.created_at, c.updated_at
FROM chats c
WHERE c.is_group = false
AND c.id IN (
    SELECT cm.chat_id
    FROM chat_members cm
    WHERE cm.user_id = ANY($1::uuid[])
    GROUP BY cm.chat_id
    HAVING COUNT(DISTINCT cm.user_id) = $2::bigint
    AND ARRAY_AGG(cm.user_id ORDER BY cm.user_id) = $1
)
LIMIT 1
`

type GetChatByMembersParams struct {
	MemberIds   []uuid.UUID `json:"member_ids"`
	MemberCount int64       `json:"member_count"`
}

type GetChatByMembersRow struct {
	ID        uuid.UUID      `json:"id"`
	Name      sql.NullString `json:"name"`
	IsGroup   bool           `json:"is_group"`
	CreatedBy uuid.UUID      `json:"created_by"`
	CreatedAt time.Time      `json:"created_at"`
	UpdatedAt time.Time      `json:"updated_at"`
}

func (q *Queries) GetChatByMembers(ctx context.Context, arg GetChatByMembersParams) (GetChatByMembersRow, error) {
	row := q.db.QueryRowContext(ctx, getChatByMembers, pq.Array(arg.MemberIds), arg.MemberCount)
	var i GetChatByMembersRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.IsGroup,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getChatDeletionStats = `-- name: GetChatDeletionStats :one
SELECT
    COUNT(*)::int AS member_count,
    COALESCE(SUM(CASE WHEN deleted_at IS NOT NULL THEN 1 ELSE 0 END), 0)::int AS deleted_count
FROM chat_members
WHERE chat_id = $1
`

type GetChatDeletionStatsRow struct {
	MemberCount  int32 `json:"member_count"`
	DeletedCount int32 `json:"deleted_count"`
}

func (q *Queries) GetChatDeletionStats(ctx context.Context, chatID uuid.UUID) (GetChatDeletionStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getChatDeletionStats, chatID)
	var i GetChatDeletionStatsRow
	err := row.Scan(&i.MemberCount, &i.DeletedCount)
	return i, err
}

const getChatMember = `-- name: GetChatMember :one
SELECT id, chat_id, user_id, joined_at, cleared_at, deleted_at
FROM chat_members
WHERE chat_id = $1 AND user_id = $2
`

type GetChatMemberParams struct {
	ChatID uuid.UUID `json:"chat_id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) GetChatMember(ctx context.Context, arg GetChatMemberParams) (ChatMember, error) {
	row := q.db.QueryRowContext(ctx, getChatMember, arg.ChatID, arg.UserID)
	var i ChatMember
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.UserID,
		&i.JoinedAt,
		&i.ClearedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getChatMetadata = `-- name: GetChatMetadata :one
SELECT id, name, is_group, created_by, created_at, updated_at
FROM chats
WHERE id = $1
`

type GetChatMetadataRow struct {
	ID        uuid.UUID      `json:"id"`
	Name      sql.NullString `json:"name"`
	IsGroup   bool           `json:"is_group"`
	CreatedBy uuid.UUID      `json:"created_by"`
	CreatedAt time.Time      `json:"created_at"`
	UpdatedAt time.Time      `json:"updated_at"`
}

func (q *Queries) GetChatMetadata(ctx context.Context, id uuid.UUID) (GetChatMetadataRow, error) {
	row := q.db.QueryRowContext(ctx, getChatMetadata, id)
	var i GetChatMetadataRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.IsGroup,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getChatsWithMembers = `-- name: GetChatsWithMembers :many
WITH user_chats AS (
    SELECT
        c.id,
        c.name,
        c.is_group,
        c.created_by,
        c.created_at,
        c.updated_at,
        cm_user.deleted_at as user_deleted_at,
        cm_user.cleared_at as user_cleared_at,
        lm.id as msg_id,
        lm.content as msg_content,
        lm.sender_id as msg_sender_id,
        lm.is_deleted as msg_is_deleted,
        lm.created_at as msg_created_at,
        sender.username as msg_sender_username,
        sender.profile_image_url as msg_sender_profile_image_url,
        ROW_NUMBER() OVER (PARTITION BY c.id ORDER BY COALESCE(lm.created_at, c.created_at) DESC) as rn
    FROM chats c
    INNER JOIN chat_members cm_user ON c.id = cm_user.chat_id AND cm_user.user_id = $1
    LEFT JOIN LATERAL (
        SELECT id, chat_id, sender_id, content, is_deleted, created_at
        FROM messages
        WHERE chat_id = c.id
          AND (cm_user.cleared_at IS NULL OR created_at > cm_user.cleared_at)
        ORDER BY created_at DESC
        LIMIT 1
    ) lm ON true
    LEFT JOIN users sender ON lm.sender_id = sender.id
)
SELECT
    uc.id as chat_id,
    uc.name as chat_name,
    uc.is_group,
    uc.created_by,
    uc.created_at as chat_created_at,
    uc.updated_at as chat_updated_at,
    u.id as member_id,
    u.username as member_username,
    u.email as member_email,
    u.profile_image_url as member_profile_image_url,
    COALESCE(uc.msg_id, '00000000-0000-0000-0000-000000000000'::uuid) as last_message_id,
    uc.msg_content as last_message_content,
    COALESCE(uc.msg_sender_id, '00000000-0000-0000-0000-000000000000'::uuid) as last_message_sender_id,
    COALESCE(uc.msg_is_deleted, false) as last_message_is_deleted,
    COALESCE(uc.msg_created_at, uc.created_at) as last_message_created_at,
    uc.msg_sender_username as last_message_sender_username,
    uc.msg_sender_profile_image_url as last_message_sender_profile_image_url
FROM user_chats uc
INNER JOIN chat_members cm ON uc.id = cm.chat_id
INNER JOIN users u ON cm.user_id = u.id
WHERE uc.rn = 1
  AND (uc.user_deleted_at IS NULL OR COALESCE(uc.msg_created_at, uc.created_at) > uc.user_deleted_at)
ORDER BY COALESCE(uc.msg_created_at, uc.created_at) DESC, u.username ASC
`

type GetChatsWithMembersRow struct {
	ChatID                           uuid.UUID      `json:"chat_id"`
	ChatName                         sql.NullString `json:"chat_name"`
	IsGroup                          bool           `json:"is_group"`
	CreatedBy                        uuid.UUID      `json:"created_by"`
	ChatCreatedAt                    time.Time      `json:"chat_created_at"`
	ChatUpdatedAt                    time.Time      `json:"chat_updated_at"`
	MemberID                         uuid.UUID      `json:"member_id"`
	MemberUsername                   string         `json:"member_username"`
	MemberEmail                      string         `json:"member_email"`
	MemberProfileImageUrl            sql.NullString `json:"member_profile_image_url"`
	LastMessageID                    uuid.UUID      `json:"last_message_id"`
	LastMessageContent               sql.NullString `json:"last_message_content"`
	LastMessageSenderID              uuid.UUID      `json:"last_message_sender_id"`
	LastMessageIsDeleted             bool           `json:"last_message_is_deleted"`
	LastMessageCreatedAt             time.Time      `json:"last_message_created_at"`
	LastMessageSenderUsername        sql.NullString `json:"last_message_sender_username"`
	LastMessageSenderProfileImageUrl sql.NullString `json:"last_message_sender_profile_image_url"`
}

func (q *Queries) GetChatsWithMembers(ctx context.Context, userID uuid.UUID) ([]GetChatsWithMembersRow, error) {
	rows, err := q.db.QueryContext(ctx, getChatsWithMembers, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetChatsWithMembersRow{}
	for rows.Next() {
		var i GetChatsWithMembersRow
		if err := rows.Scan(
			&i.ChatID,
			&i.ChatName,
			&i.IsGroup,
			&i.CreatedBy,
			&i.ChatCreatedAt,
			&i.ChatUpdatedAt,
			&i.MemberID,
			&i.MemberUsername,
			&i.MemberEmail,
			&i.MemberProfileImageUrl,
			&i.LastMessageID,
			&i.LastMessageContent,
			&i.LastMessageSenderID,
			&i.LastMessageIsDeleted,
			&i.LastMessageCreatedAt,
			&i.LastMessageSenderUsername,
			&i.LastMessageSenderProfileImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastMessageImages = `-- name: GetLastMessageImages :many
SELECT message_id, url
FROM images
WHERE message_id = ANY($1::uuid[])
`

type GetLastMessageImagesRow struct {
	MessageID uuid.UUID `json:"message_id"`
	Url       string    `json:"url"`
}

func (q *Queries) GetLastMessageImages(ctx context.Context, dollar_1 []uuid.UUID) ([]GetLastMessageImagesRow, error) {
	rows, err := q.db.QueryContext(ctx, getLastMessageImages, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLastMessageImagesRow{}
	for rows.Next() {
		var i GetLastMessageImagesRow
		if err := rows.Scan(&i.MessageID, &i.Url); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeChatMember = `-- name: RemoveChatMember :exec
DELETE FROM chat_members
WHERE chat_id = $1 AND user_id = $2
`

type RemoveChatMemberParams struct {
	ChatID uuid.UUID `json:"chat_id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) RemoveChatMember(ctx context.Context, arg RemoveChatMemberParams) error {
	_, err := q.db.ExecContext(ctx, removeChatMember, arg.ChatID, arg.UserID)
	return err
}

const searchUsers = `-- name: SearchUsers :many
SELECT id, username, email, profile_image_url, created_at, updated_at
FROM users
WHERE username ILIKE '%' || $1 || '%'
AND id != ALL($2::uuid[])
LIMIT 20
`

type SearchUsersParams struct {
	Query       sql.NullString `json:"query"`
	ExcludedIds []uuid.UUID    `json:"excluded_ids"`
}

type SearchUsersRow struct {
	ID              uuid.UUID      `json:"id"`
	Username        string         `json:"username"`
	Email           string         `json:"email"`
	ProfileImageUrl sql.NullString `json:"profile_image_url"`
	CreatedAt       time.Time      `json:"created_at"`
	UpdatedAt       time.Time      `json:"updated_at"`
}

func (q *Queries) SearchUsers(ctx context.Context, arg SearchUsersParams) ([]SearchUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, searchUsers, arg.Query, pq.Array(arg.ExcludedIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchUsersRow{}
	for rows.Next() {
		var i SearchUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.ProfileImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateChatCreator = `-- name: UpdateChatCreator :exec
UPDATE chats
SET created_by = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateChatCreatorParams struct {
	ID        uuid.UUID `json:"id"`
	CreatedBy uuid.UUID `json:"created_by"`
}

func (q *Queries) UpdateChatCreator(ctx context.Context, arg UpdateChatCreatorParams) error {
	_, err := q.db.ExecContext(ctx, updateChatCreator, arg.ID, arg.CreatedBy)
	return err
}

const updateChatMemberClearedAt = `-- name: UpdateChatMemberClearedAt :exec
UPDATE chat_members
SET cleared_at = CURRENT_TIMESTAMP
WHERE chat_id = $1 AND user_id = $2
`

type UpdateChatMemberClearedAtParams struct {
	ChatID uuid.UUID `json:"chat_id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) UpdateChatMemberClearedAt(ctx context.Context, arg UpdateChatMemberClearedAtParams) error {
	_, err := q.db.ExecContext(ctx, updateChatMemberClearedAt, arg.ChatID, arg.UserID)
	return err
}

const updateChatMemberDeletedAt = `-- name: UpdateChatMemberDeletedAt :exec
UPDATE chat_members
SET deleted_at = $3
WHERE chat_id = $1 AND user_id = $2
`

type UpdateChatMemberDeletedAtParams struct {
	ChatID    uuid.UUID    `json:"chat_id"`
	UserID    uuid.UUID    `json:"user_id"`
	DeletedAt sql.NullTime `json:"deleted_at"`
}

func (q *Queries) UpdateChatMemberDeletedAt(ctx context.Context, arg UpdateChatMemberDeletedAtParams) error {
	_, err := q.db.ExecContext(ctx, updateChatMemberDeletedAt, arg.ChatID, arg.UserID, arg.DeletedAt)
	return err
}

const updateChatName = `-- name: UpdateChatName :exec
UPDATE chats
SET name = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateChatNameParams struct {
	ID   uuid.UUID      `json:"id"`
	Name sql.NullString `json:"name"`
}

func (q *Queries) UpdateChatName(ctx context.Context, arg UpdateChatNameParams) error {
	_, err := q.db.ExecContext(ctx, updateChatName, arg.ID, arg.Name)
	return err
}
