// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: chats.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const addChatMember = `-- name: AddChatMember :exec
INSERT INTO chat_members (chat_id, user_id)
VALUES ($1, $2)
`

type AddChatMemberParams struct {
	ChatID uuid.UUID `json:"chat_id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) AddChatMember(ctx context.Context, arg AddChatMemberParams) error {
	_, err := q.db.ExecContext(ctx, addChatMember, arg.ChatID, arg.UserID)
	return err
}

const createChat = `-- name: CreateChat :one
INSERT INTO chats (name, is_group)
VALUES ($1, $2)
RETURNING id, name, is_group, created_at, updated_at
`

type CreateChatParams struct {
	Name    sql.NullString `json:"name"`
	IsGroup bool           `json:"is_group"`
}

func (q *Queries) CreateChat(ctx context.Context, arg CreateChatParams) (Chat, error) {
	row := q.db.QueryRowContext(ctx, createChat, arg.Name, arg.IsGroup)
	var i Chat
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.IsGroup,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getChatByIdWithMembers = `-- name: GetChatByIdWithMembers :many
SELECT
    c.id as chat_id,
    c.name as chat_name,
    c.is_group,
    c.created_at as chat_created_at,
    c.updated_at as chat_updated_at,
    u.id as member_id,
    u.username as member_username,
    u.email as member_email
FROM chats c
INNER JOIN chat_members cm ON c.id = cm.chat_id
INNER JOIN users u ON cm.user_id = u.id
WHERE c.id = $1
ORDER BY u.username ASC
`

type GetChatByIdWithMembersRow struct {
	ChatID         uuid.UUID      `json:"chat_id"`
	ChatName       sql.NullString `json:"chat_name"`
	IsGroup        bool           `json:"is_group"`
	ChatCreatedAt  time.Time      `json:"chat_created_at"`
	ChatUpdatedAt  time.Time      `json:"chat_updated_at"`
	MemberID       uuid.UUID      `json:"member_id"`
	MemberUsername string         `json:"member_username"`
	MemberEmail    string         `json:"member_email"`
}

func (q *Queries) GetChatByIdWithMembers(ctx context.Context, id uuid.UUID) ([]GetChatByIdWithMembersRow, error) {
	rows, err := q.db.QueryContext(ctx, getChatByIdWithMembers, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetChatByIdWithMembersRow{}
	for rows.Next() {
		var i GetChatByIdWithMembersRow
		if err := rows.Scan(
			&i.ChatID,
			&i.ChatName,
			&i.IsGroup,
			&i.ChatCreatedAt,
			&i.ChatUpdatedAt,
			&i.MemberID,
			&i.MemberUsername,
			&i.MemberEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChatByMembers = `-- name: GetChatByMembers :one
SELECT c.id, c.name, c.is_group, c.created_at, c.updated_at
FROM chats c
WHERE c.is_group = false
AND c.id IN (
    SELECT cm.chat_id
    FROM chat_members cm
    WHERE cm.user_id = ANY($1::uuid[])
    GROUP BY cm.chat_id
    HAVING COUNT(DISTINCT cm.user_id) = $2::bigint
)
LIMIT 1
`

type GetChatByMembersParams struct {
	MemberIds   []uuid.UUID `json:"member_ids"`
	MemberCount int64       `json:"member_count"`
}

func (q *Queries) GetChatByMembers(ctx context.Context, arg GetChatByMembersParams) (Chat, error) {
	row := q.db.QueryRowContext(ctx, getChatByMembers, pq.Array(arg.MemberIds), arg.MemberCount)
	var i Chat
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.IsGroup,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getChatsWithMembers = `-- name: GetChatsWithMembers :many
SELECT
    c.id as chat_id,
    c.name as chat_name,
    c.is_group,
    c.created_at as chat_created_at,
    c.updated_at as chat_updated_at,
    u.id as member_id,
    u.username as member_username,
    u.email as member_email,
    COALESCE(c.msg_id, '00000000-0000-0000-0000-000000000000'::uuid) as last_message_id,
    c.msg_content as last_message_content,
    COALESCE(c.msg_sender_id, '00000000-0000-0000-0000-000000000000'::uuid) as last_message_sender_id,
    COALESCE(c.msg_is_deleted, false) as last_message_is_deleted,
    COALESCE(c.msg_created_at, c.created_at) as last_message_created_at,
    c.msg_sender_username as last_message_sender_username
FROM (
    SELECT
        c.id,
        c.name,
        c.is_group,
        c.created_at,
        c.updated_at,
        lm.id as msg_id,
        lm.content as msg_content,
        lm.sender_id as msg_sender_id,
        lm.is_deleted as msg_is_deleted,
        lm.created_at as msg_created_at,
        sender.username as msg_sender_username,
        ROW_NUMBER() OVER (PARTITION BY c.id ORDER BY COALESCE(lm.created_at, c.created_at) DESC) as rn
    FROM chats c
    LEFT JOIN LATERAL (
        SELECT id, chat_id, sender_id, content, is_deleted, created_at
        FROM messages
        WHERE chat_id = c.id
        ORDER BY created_at DESC
        LIMIT 1
    ) lm ON true
    LEFT JOIN users sender ON lm.sender_id = sender.id
    WHERE c.id IN (
        SELECT DISTINCT cm2.chat_id
        FROM chat_members cm2
        WHERE cm2.user_id = $1
    )
) c
INNER JOIN chat_members cm ON c.id = cm.chat_id
INNER JOIN users u ON cm.user_id = u.id
WHERE c.rn = 1
ORDER BY COALESCE(c.msg_created_at, c.created_at) DESC, u.username ASC
`

type GetChatsWithMembersRow struct {
	ChatID                    uuid.UUID      `json:"chat_id"`
	ChatName                  sql.NullString `json:"chat_name"`
	IsGroup                   bool           `json:"is_group"`
	ChatCreatedAt             time.Time      `json:"chat_created_at"`
	ChatUpdatedAt             time.Time      `json:"chat_updated_at"`
	MemberID                  uuid.UUID      `json:"member_id"`
	MemberUsername            string         `json:"member_username"`
	MemberEmail               string         `json:"member_email"`
	LastMessageID             uuid.UUID      `json:"last_message_id"`
	LastMessageContent        sql.NullString `json:"last_message_content"`
	LastMessageSenderID       uuid.UUID      `json:"last_message_sender_id"`
	LastMessageIsDeleted      bool           `json:"last_message_is_deleted"`
	LastMessageCreatedAt      time.Time      `json:"last_message_created_at"`
	LastMessageSenderUsername sql.NullString `json:"last_message_sender_username"`
}

func (q *Queries) GetChatsWithMembers(ctx context.Context, userID uuid.UUID) ([]GetChatsWithMembersRow, error) {
	rows, err := q.db.QueryContext(ctx, getChatsWithMembers, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetChatsWithMembersRow{}
	for rows.Next() {
		var i GetChatsWithMembersRow
		if err := rows.Scan(
			&i.ChatID,
			&i.ChatName,
			&i.IsGroup,
			&i.ChatCreatedAt,
			&i.ChatUpdatedAt,
			&i.MemberID,
			&i.MemberUsername,
			&i.MemberEmail,
			&i.LastMessageID,
			&i.LastMessageContent,
			&i.LastMessageSenderID,
			&i.LastMessageIsDeleted,
			&i.LastMessageCreatedAt,
			&i.LastMessageSenderUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastMessageImages = `-- name: GetLastMessageImages :many
SELECT message_id, url
FROM images
WHERE message_id = ANY($1::uuid[])
`

type GetLastMessageImagesRow struct {
	MessageID uuid.UUID `json:"message_id"`
	Url       string    `json:"url"`
}

func (q *Queries) GetLastMessageImages(ctx context.Context, dollar_1 []uuid.UUID) ([]GetLastMessageImagesRow, error) {
	rows, err := q.db.QueryContext(ctx, getLastMessageImages, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLastMessageImagesRow{}
	for rows.Next() {
		var i GetLastMessageImagesRow
		if err := rows.Scan(&i.MessageID, &i.Url); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchUsers = `-- name: SearchUsers :many
SELECT id, username, email, created_at, updated_at
FROM users
WHERE username ILIKE '%' || $1 || '%'
AND id != ALL($2::uuid[])
LIMIT 20
`

type SearchUsersParams struct {
	Query       sql.NullString `json:"query"`
	ExcludedIds []uuid.UUID    `json:"excluded_ids"`
}

type SearchUsersRow struct {
	ID        uuid.UUID `json:"id"`
	Username  string    `json:"username"`
	Email     string    `json:"email"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) SearchUsers(ctx context.Context, arg SearchUsersParams) ([]SearchUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, searchUsers, arg.Query, pq.Array(arg.ExcludedIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchUsersRow{}
	for rows.Next() {
		var i SearchUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
