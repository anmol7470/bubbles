// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: messages.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const addMessageImage = `-- name: AddMessageImage :exec
INSERT INTO images (message_id, url)
VALUES ($1, $2)
`

type AddMessageImageParams struct {
	MessageID uuid.UUID `json:"message_id"`
	Url       string    `json:"url"`
}

func (q *Queries) AddMessageImage(ctx context.Context, arg AddMessageImageParams) error {
	_, err := q.db.ExecContext(ctx, addMessageImage, arg.MessageID, arg.Url)
	return err
}

const createMessage = `-- name: CreateMessage :one
INSERT INTO messages (chat_id, sender_id, content, reply_to_message_id)
VALUES ($1, $2, $3, $4)
RETURNING id, chat_id, sender_id, content, is_deleted, created_at, updated_at, is_edited, reply_to_message_id
`

type CreateMessageParams struct {
	ChatID           uuid.UUID      `json:"chat_id"`
	SenderID         uuid.UUID      `json:"sender_id"`
	Content          sql.NullString `json:"content"`
	ReplyToMessageID uuid.NullUUID  `json:"reply_to_message_id"`
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (Message, error) {
	row := q.db.QueryRowContext(ctx, createMessage,
		arg.ChatID,
		arg.SenderID,
		arg.Content,
		arg.ReplyToMessageID,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.SenderID,
		&i.Content,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsEdited,
		&i.ReplyToMessageID,
	)
	return i, err
}

const deleteImageByUrl = `-- name: DeleteImageByUrl :exec
DELETE FROM images
WHERE url = $1
`

func (q *Queries) DeleteImageByUrl(ctx context.Context, url string) error {
	_, err := q.db.ExecContext(ctx, deleteImageByUrl, url)
	return err
}

const deleteMessage = `-- name: DeleteMessage :exec
UPDATE messages
SET is_deleted = true, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) DeleteMessage(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteMessage, id)
	return err
}

const deleteMessageImages = `-- name: DeleteMessageImages :exec
DELETE FROM images
WHERE message_id = $1 AND url = ANY($2::text[])
`

type DeleteMessageImagesParams struct {
	MessageID uuid.UUID `json:"message_id"`
	Column2   []string  `json:"column_2"`
}

func (q *Queries) DeleteMessageImages(ctx context.Context, arg DeleteMessageImagesParams) error {
	_, err := q.db.ExecContext(ctx, deleteMessageImages, arg.MessageID, pq.Array(arg.Column2))
	return err
}

const editMessage = `-- name: EditMessage :exec
UPDATE messages
SET content = $2, is_edited = true, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type EditMessageParams struct {
	ID      uuid.UUID      `json:"id"`
	Content sql.NullString `json:"content"`
}

func (q *Queries) EditMessage(ctx context.Context, arg EditMessageParams) error {
	_, err := q.db.ExecContext(ctx, editMessage, arg.ID, arg.Content)
	return err
}

const getChatImageUrls = `-- name: GetChatImageUrls :many
SELECT i.url
FROM images i
INNER JOIN messages m ON i.message_id = m.id
WHERE m.chat_id = $1
`

func (q *Queries) GetChatImageUrls(ctx context.Context, chatID uuid.UUID) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getChatImageUrls, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var url string
		if err := rows.Scan(&url); err != nil {
			return nil, err
		}
		items = append(items, url)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChatReadReceipts = `-- name: GetChatReadReceipts :many
SELECT chat_id, user_id, last_read_message_id, last_read_at
FROM chat_read_receipts
WHERE chat_id = $1
`

func (q *Queries) GetChatReadReceipts(ctx context.Context, chatID uuid.UUID) ([]ChatReadReceipt, error) {
	rows, err := q.db.QueryContext(ctx, getChatReadReceipts, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ChatReadReceipt{}
	for rows.Next() {
		var i ChatReadReceipt
		if err := rows.Scan(
			&i.ChatID,
			&i.UserID,
			&i.LastReadMessageID,
			&i.LastReadAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessageById = `-- name: GetMessageById :one
SELECT
    m.id,
    m.chat_id,
    m.sender_id,
    m.content,
    m.is_deleted,
    m.is_edited,
    m.reply_to_message_id,
    m.created_at,
    m.updated_at
FROM messages m
WHERE m.id = $1
`

type GetMessageByIdRow struct {
	ID               uuid.UUID      `json:"id"`
	ChatID           uuid.UUID      `json:"chat_id"`
	SenderID         uuid.UUID      `json:"sender_id"`
	Content          sql.NullString `json:"content"`
	IsDeleted        bool           `json:"is_deleted"`
	IsEdited         bool           `json:"is_edited"`
	ReplyToMessageID uuid.NullUUID  `json:"reply_to_message_id"`
	CreatedAt        time.Time      `json:"created_at"`
	UpdatedAt        time.Time      `json:"updated_at"`
}

func (q *Queries) GetMessageById(ctx context.Context, id uuid.UUID) (GetMessageByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getMessageById, id)
	var i GetMessageByIdRow
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.SenderID,
		&i.Content,
		&i.IsDeleted,
		&i.IsEdited,
		&i.ReplyToMessageID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMessageImages = `-- name: GetMessageImages :many
SELECT id, message_id, url, created_at
FROM images
WHERE message_id = ANY($1::uuid[])
`

func (q *Queries) GetMessageImages(ctx context.Context, dollar_1 []uuid.UUID) ([]Image, error) {
	rows, err := q.db.QueryContext(ctx, getMessageImages, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Image{}
	for rows.Next() {
		var i Image
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.Url,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessagesByChat = `-- name: GetMessagesByChat :many
SELECT
    m.id,
    m.chat_id,
    m.sender_id,
    m.content,
    m.is_deleted,
    m.is_edited,
    m.reply_to_message_id,
    m.created_at,
    m.updated_at,
    u.username as sender_username,
    u.profile_image_url as sender_profile_image_url,
    rm.content AS reply_content,
    rm.is_deleted AS reply_is_deleted,
    rm.sender_id AS reply_sender_id,
    ru.username AS reply_sender_username,
    ru.profile_image_url AS reply_sender_profile_image_url
FROM messages m
INNER JOIN users u ON m.sender_id = u.id
LEFT JOIN messages rm ON m.reply_to_message_id = rm.id
LEFT JOIN users ru ON rm.sender_id = ru.id
WHERE m.chat_id = $1
ORDER BY m.created_at ASC
LIMIT 50
`

type GetMessagesByChatRow struct {
	ID                         uuid.UUID      `json:"id"`
	ChatID                     uuid.UUID      `json:"chat_id"`
	SenderID                   uuid.UUID      `json:"sender_id"`
	Content                    sql.NullString `json:"content"`
	IsDeleted                  bool           `json:"is_deleted"`
	IsEdited                   bool           `json:"is_edited"`
	ReplyToMessageID           uuid.NullUUID  `json:"reply_to_message_id"`
	CreatedAt                  time.Time      `json:"created_at"`
	UpdatedAt                  time.Time      `json:"updated_at"`
	SenderUsername             string         `json:"sender_username"`
	SenderProfileImageUrl      sql.NullString `json:"sender_profile_image_url"`
	ReplyContent               sql.NullString `json:"reply_content"`
	ReplyIsDeleted             sql.NullBool   `json:"reply_is_deleted"`
	ReplySenderID              uuid.NullUUID  `json:"reply_sender_id"`
	ReplySenderUsername        sql.NullString `json:"reply_sender_username"`
	ReplySenderProfileImageUrl sql.NullString `json:"reply_sender_profile_image_url"`
}

func (q *Queries) GetMessagesByChat(ctx context.Context, chatID uuid.UUID) ([]GetMessagesByChatRow, error) {
	rows, err := q.db.QueryContext(ctx, getMessagesByChat, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMessagesByChatRow{}
	for rows.Next() {
		var i GetMessagesByChatRow
		if err := rows.Scan(
			&i.ID,
			&i.ChatID,
			&i.SenderID,
			&i.Content,
			&i.IsDeleted,
			&i.IsEdited,
			&i.ReplyToMessageID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SenderUsername,
			&i.SenderProfileImageUrl,
			&i.ReplyContent,
			&i.ReplyIsDeleted,
			&i.ReplySenderID,
			&i.ReplySenderUsername,
			&i.ReplySenderProfileImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessagesByChatPaginated = `-- name: GetMessagesByChatPaginated :many
SELECT
    m.id,
    m.chat_id,
    m.sender_id,
    m.content,
    m.is_deleted,
    m.is_edited,
    m.reply_to_message_id,
    m.created_at,
    m.updated_at,
    u.username as sender_username,
    u.profile_image_url as sender_profile_image_url,
    rm.content AS reply_content,
    rm.is_deleted AS reply_is_deleted,
    rm.sender_id AS reply_sender_id,
    ru.username AS reply_sender_username,
    ru.profile_image_url AS reply_sender_profile_image_url
FROM messages m
INNER JOIN chat_members cm_filter ON cm_filter.chat_id = m.chat_id AND cm_filter.user_id = $1::uuid
INNER JOIN users u ON m.sender_id = u.id
LEFT JOIN messages rm ON m.reply_to_message_id = rm.id
LEFT JOIN users ru ON rm.sender_id = ru.id
WHERE m.chat_id = $2::uuid
  AND (cm_filter.cleared_at IS NULL OR m.created_at > cm_filter.cleared_at)
  AND (
    $3::timestamp IS NULL OR
    m.created_at < $3::timestamp OR
    (m.created_at = $3::timestamp AND m.id < $4::uuid)
  )
ORDER BY m.created_at DESC, m.id DESC
LIMIT $5
`

type GetMessagesByChatPaginatedParams struct {
	UserID     uuid.UUID     `json:"user_id"`
	ChatID     uuid.UUID     `json:"chat_id"`
	CursorTime sql.NullTime  `json:"cursor_time"`
	CursorID   uuid.NullUUID `json:"cursor_id"`
	PageLimit  int32         `json:"page_limit"`
}

type GetMessagesByChatPaginatedRow struct {
	ID                         uuid.UUID      `json:"id"`
	ChatID                     uuid.UUID      `json:"chat_id"`
	SenderID                   uuid.UUID      `json:"sender_id"`
	Content                    sql.NullString `json:"content"`
	IsDeleted                  bool           `json:"is_deleted"`
	IsEdited                   bool           `json:"is_edited"`
	ReplyToMessageID           uuid.NullUUID  `json:"reply_to_message_id"`
	CreatedAt                  time.Time      `json:"created_at"`
	UpdatedAt                  time.Time      `json:"updated_at"`
	SenderUsername             string         `json:"sender_username"`
	SenderProfileImageUrl      sql.NullString `json:"sender_profile_image_url"`
	ReplyContent               sql.NullString `json:"reply_content"`
	ReplyIsDeleted             sql.NullBool   `json:"reply_is_deleted"`
	ReplySenderID              uuid.NullUUID  `json:"reply_sender_id"`
	ReplySenderUsername        sql.NullString `json:"reply_sender_username"`
	ReplySenderProfileImageUrl sql.NullString `json:"reply_sender_profile_image_url"`
}

func (q *Queries) GetMessagesByChatPaginated(ctx context.Context, arg GetMessagesByChatPaginatedParams) ([]GetMessagesByChatPaginatedRow, error) {
	rows, err := q.db.QueryContext(ctx, getMessagesByChatPaginated,
		arg.UserID,
		arg.ChatID,
		arg.CursorTime,
		arg.CursorID,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMessagesByChatPaginatedRow{}
	for rows.Next() {
		var i GetMessagesByChatPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.ChatID,
			&i.SenderID,
			&i.Content,
			&i.IsDeleted,
			&i.IsEdited,
			&i.ReplyToMessageID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SenderUsername,
			&i.SenderProfileImageUrl,
			&i.ReplyContent,
			&i.ReplyIsDeleted,
			&i.ReplySenderID,
			&i.ReplySenderUsername,
			&i.ReplySenderProfileImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertChatReadReceipt = `-- name: UpsertChatReadReceipt :exec
INSERT INTO chat_read_receipts (chat_id, user_id, last_read_message_id, last_read_at)
VALUES ($1, $2, $3, $4)
ON CONFLICT (chat_id, user_id) DO UPDATE
SET
    last_read_message_id = CASE
        WHEN chat_read_receipts.last_read_at <= excluded.last_read_at THEN excluded.last_read_message_id
        ELSE chat_read_receipts.last_read_message_id
    END,
    last_read_at = GREATEST(chat_read_receipts.last_read_at, excluded.last_read_at)
`

type UpsertChatReadReceiptParams struct {
	ChatID            uuid.UUID `json:"chat_id"`
	UserID            uuid.UUID `json:"user_id"`
	LastReadMessageID uuid.UUID `json:"last_read_message_id"`
	LastReadAt        time.Time `json:"last_read_at"`
}

func (q *Queries) UpsertChatReadReceipt(ctx context.Context, arg UpsertChatReadReceiptParams) error {
	_, err := q.db.ExecContext(ctx, upsertChatReadReceipt,
		arg.ChatID,
		arg.UserID,
		arg.LastReadMessageID,
		arg.LastReadAt,
	)
	return err
}
