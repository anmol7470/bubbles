// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: messages.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const addMessageImage = `-- name: AddMessageImage :exec
INSERT INTO images (message_id, url)
VALUES ($1, $2)
`

type AddMessageImageParams struct {
	MessageID uuid.UUID `json:"message_id"`
	Url       string    `json:"url"`
}

func (q *Queries) AddMessageImage(ctx context.Context, arg AddMessageImageParams) error {
	_, err := q.db.ExecContext(ctx, addMessageImage, arg.MessageID, arg.Url)
	return err
}

const createMessage = `-- name: CreateMessage :one
INSERT INTO messages (chat_id, sender_id, content)
VALUES ($1, $2, $3)
RETURNING id, chat_id, sender_id, content, is_deleted, created_at, updated_at
`

type CreateMessageParams struct {
	ChatID   uuid.UUID      `json:"chat_id"`
	SenderID uuid.UUID      `json:"sender_id"`
	Content  sql.NullString `json:"content"`
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (Message, error) {
	row := q.db.QueryRowContext(ctx, createMessage, arg.ChatID, arg.SenderID, arg.Content)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.SenderID,
		&i.Content,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteMessage = `-- name: DeleteMessage :exec
UPDATE messages
SET is_deleted = true, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) DeleteMessage(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteMessage, id)
	return err
}

const getMessageImages = `-- name: GetMessageImages :many
SELECT id, message_id, url, created_at
FROM images
WHERE message_id = ANY($1::uuid[])
`

func (q *Queries) GetMessageImages(ctx context.Context, dollar_1 []uuid.UUID) ([]Image, error) {
	rows, err := q.db.QueryContext(ctx, getMessageImages, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Image{}
	for rows.Next() {
		var i Image
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.Url,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessagesByChat = `-- name: GetMessagesByChat :many
SELECT
    m.id,
    m.chat_id,
    m.sender_id,
    m.content,
    m.is_deleted,
    m.created_at,
    m.updated_at,
    u.username as sender_username,
    u.email as sender_email
FROM messages m
INNER JOIN users u ON m.sender_id = u.id
WHERE m.chat_id = $1
ORDER BY m.created_at ASC
LIMIT 50
`

type GetMessagesByChatRow struct {
	ID             uuid.UUID      `json:"id"`
	ChatID         uuid.UUID      `json:"chat_id"`
	SenderID       uuid.UUID      `json:"sender_id"`
	Content        sql.NullString `json:"content"`
	IsDeleted      bool           `json:"is_deleted"`
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      time.Time      `json:"updated_at"`
	SenderUsername string         `json:"sender_username"`
	SenderEmail    string         `json:"sender_email"`
}

func (q *Queries) GetMessagesByChat(ctx context.Context, chatID uuid.UUID) ([]GetMessagesByChatRow, error) {
	rows, err := q.db.QueryContext(ctx, getMessagesByChat, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMessagesByChatRow{}
	for rows.Next() {
		var i GetMessagesByChatRow
		if err := rows.Scan(
			&i.ID,
			&i.ChatID,
			&i.SenderID,
			&i.Content,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SenderUsername,
			&i.SenderEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessagesByChatPaginated = `-- name: GetMessagesByChatPaginated :many
SELECT
    m.id,
    m.chat_id,
    m.sender_id,
    m.content,
    m.is_deleted,
    m.created_at,
    m.updated_at,
    u.username as sender_username,
    u.email as sender_email
FROM messages m
INNER JOIN users u ON m.sender_id = u.id
WHERE m.chat_id = $1
  AND (
    $3::timestamp IS NULL OR
    m.created_at < $3::timestamp OR
    (m.created_at = $3::timestamp AND m.id < $4::uuid)
  )
ORDER BY m.created_at DESC, m.id DESC
LIMIT $2
`

type GetMessagesByChatPaginatedParams struct {
	ChatID     uuid.UUID     `json:"chat_id"`
	Limit      int32         `json:"limit"`
	CursorTime sql.NullTime  `json:"cursor_time"`
	CursorID   uuid.NullUUID `json:"cursor_id"`
}

type GetMessagesByChatPaginatedRow struct {
	ID             uuid.UUID      `json:"id"`
	ChatID         uuid.UUID      `json:"chat_id"`
	SenderID       uuid.UUID      `json:"sender_id"`
	Content        sql.NullString `json:"content"`
	IsDeleted      bool           `json:"is_deleted"`
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      time.Time      `json:"updated_at"`
	SenderUsername string         `json:"sender_username"`
	SenderEmail    string         `json:"sender_email"`
}

func (q *Queries) GetMessagesByChatPaginated(ctx context.Context, arg GetMessagesByChatPaginatedParams) ([]GetMessagesByChatPaginatedRow, error) {
	rows, err := q.db.QueryContext(ctx, getMessagesByChatPaginated,
		arg.ChatID,
		arg.Limit,
		arg.CursorTime,
		arg.CursorID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMessagesByChatPaginatedRow{}
	for rows.Next() {
		var i GetMessagesByChatPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.ChatID,
			&i.SenderID,
			&i.Content,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SenderUsername,
			&i.SenderEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
