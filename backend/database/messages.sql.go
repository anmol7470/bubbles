// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: messages.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const addMessageImage = `-- name: AddMessageImage :exec
INSERT INTO images (message_id, url)
VALUES ($1, $2)
`

type AddMessageImageParams struct {
	MessageID uuid.UUID `json:"message_id"`
	Url       string    `json:"url"`
}

func (q *Queries) AddMessageImage(ctx context.Context, arg AddMessageImageParams) error {
	_, err := q.db.ExecContext(ctx, addMessageImage, arg.MessageID, arg.Url)
	return err
}

const createMessage = `-- name: CreateMessage :one
INSERT INTO messages (chat_id, sender_id, content, reply_to_message_id)
VALUES ($1, $2, $3, $4)
RETURNING id, chat_id, sender_id, content, is_deleted, created_at, updated_at, is_edited, reply_to_message_id
`

type CreateMessageParams struct {
	ChatID           uuid.UUID      `json:"chat_id"`
	SenderID         uuid.UUID      `json:"sender_id"`
	Content          sql.NullString `json:"content"`
	ReplyToMessageID uuid.NullUUID  `json:"reply_to_message_id"`
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (Message, error) {
	row := q.db.QueryRowContext(ctx, createMessage,
		arg.ChatID,
		arg.SenderID,
		arg.Content,
		arg.ReplyToMessageID,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.SenderID,
		&i.Content,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsEdited,
		&i.ReplyToMessageID,
	)
	return i, err
}

const deleteImageByUrl = `-- name: DeleteImageByUrl :exec
DELETE FROM images
WHERE url = $1
`

func (q *Queries) DeleteImageByUrl(ctx context.Context, url string) error {
	_, err := q.db.ExecContext(ctx, deleteImageByUrl, url)
	return err
}

const deleteMessage = `-- name: DeleteMessage :exec
UPDATE messages
SET is_deleted = true, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) DeleteMessage(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteMessage, id)
	return err
}

const deleteMessageImages = `-- name: DeleteMessageImages :exec
DELETE FROM images
WHERE message_id = $1 AND url = ANY($2::text[])
`

type DeleteMessageImagesParams struct {
	MessageID uuid.UUID `json:"message_id"`
	Column2   []string  `json:"column_2"`
}

func (q *Queries) DeleteMessageImages(ctx context.Context, arg DeleteMessageImagesParams) error {
	_, err := q.db.ExecContext(ctx, deleteMessageImages, arg.MessageID, pq.Array(arg.Column2))
	return err
}

const editMessage = `-- name: EditMessage :exec
UPDATE messages
SET content = $2, is_edited = true, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type EditMessageParams struct {
	ID      uuid.UUID      `json:"id"`
	Content sql.NullString `json:"content"`
}

func (q *Queries) EditMessage(ctx context.Context, arg EditMessageParams) error {
	_, err := q.db.ExecContext(ctx, editMessage, arg.ID, arg.Content)
	return err
}

const getMessageById = `-- name: GetMessageById :one
SELECT
    m.id,
    m.chat_id,
    m.sender_id,
    m.content,
    m.is_deleted,
    m.is_edited,
    m.reply_to_message_id,
    m.created_at,
    m.updated_at
FROM messages m
WHERE m.id = $1
`

type GetMessageByIdRow struct {
	ID               uuid.UUID      `json:"id"`
	ChatID           uuid.UUID      `json:"chat_id"`
	SenderID         uuid.UUID      `json:"sender_id"`
	Content          sql.NullString `json:"content"`
	IsDeleted        bool           `json:"is_deleted"`
	IsEdited         bool           `json:"is_edited"`
	ReplyToMessageID uuid.NullUUID  `json:"reply_to_message_id"`
	CreatedAt        time.Time      `json:"created_at"`
	UpdatedAt        time.Time      `json:"updated_at"`
}

func (q *Queries) GetMessageById(ctx context.Context, id uuid.UUID) (GetMessageByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getMessageById, id)
	var i GetMessageByIdRow
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.SenderID,
		&i.Content,
		&i.IsDeleted,
		&i.IsEdited,
		&i.ReplyToMessageID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMessageImages = `-- name: GetMessageImages :many
SELECT id, message_id, url, created_at
FROM images
WHERE message_id = ANY($1::uuid[])
`

func (q *Queries) GetMessageImages(ctx context.Context, dollar_1 []uuid.UUID) ([]Image, error) {
	rows, err := q.db.QueryContext(ctx, getMessageImages, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Image{}
	for rows.Next() {
		var i Image
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.Url,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessagesByChat = `-- name: GetMessagesByChat :many
SELECT
    m.id,
    m.chat_id,
    m.sender_id,
    m.content,
    m.is_deleted,
    m.is_edited,
    m.reply_to_message_id,
    m.created_at,
    m.updated_at,
    u.username as sender_username,
    rm.content AS reply_content,
    rm.is_deleted AS reply_is_deleted,
    rm.sender_id AS reply_sender_id,
    ru.username AS reply_sender_username
FROM messages m
INNER JOIN users u ON m.sender_id = u.id
LEFT JOIN messages rm ON m.reply_to_message_id = rm.id
LEFT JOIN users ru ON rm.sender_id = ru.id
WHERE m.chat_id = $1
ORDER BY m.created_at ASC
LIMIT 50
`

type GetMessagesByChatRow struct {
	ID                  uuid.UUID      `json:"id"`
	ChatID              uuid.UUID      `json:"chat_id"`
	SenderID            uuid.UUID      `json:"sender_id"`
	Content             sql.NullString `json:"content"`
	IsDeleted           bool           `json:"is_deleted"`
	IsEdited            bool           `json:"is_edited"`
	ReplyToMessageID    uuid.NullUUID  `json:"reply_to_message_id"`
	CreatedAt           time.Time      `json:"created_at"`
	UpdatedAt           time.Time      `json:"updated_at"`
	SenderUsername      string         `json:"sender_username"`
	ReplyContent        sql.NullString `json:"reply_content"`
	ReplyIsDeleted      sql.NullBool   `json:"reply_is_deleted"`
	ReplySenderID       uuid.NullUUID  `json:"reply_sender_id"`
	ReplySenderUsername sql.NullString `json:"reply_sender_username"`
}

func (q *Queries) GetMessagesByChat(ctx context.Context, chatID uuid.UUID) ([]GetMessagesByChatRow, error) {
	rows, err := q.db.QueryContext(ctx, getMessagesByChat, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMessagesByChatRow{}
	for rows.Next() {
		var i GetMessagesByChatRow
		if err := rows.Scan(
			&i.ID,
			&i.ChatID,
			&i.SenderID,
			&i.Content,
			&i.IsDeleted,
			&i.IsEdited,
			&i.ReplyToMessageID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SenderUsername,
			&i.ReplyContent,
			&i.ReplyIsDeleted,
			&i.ReplySenderID,
			&i.ReplySenderUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessagesByChatPaginated = `-- name: GetMessagesByChatPaginated :many
SELECT
    m.id,
    m.chat_id,
    m.sender_id,
    m.content,
    m.is_deleted,
    m.is_edited,
    m.reply_to_message_id,
    m.created_at,
    m.updated_at,
    u.username as sender_username,
    rm.content AS reply_content,
    rm.is_deleted AS reply_is_deleted,
    rm.sender_id AS reply_sender_id,
    ru.username AS reply_sender_username
FROM messages m
INNER JOIN users u ON m.sender_id = u.id
LEFT JOIN messages rm ON m.reply_to_message_id = rm.id
LEFT JOIN users ru ON rm.sender_id = ru.id
WHERE m.chat_id = $1
  AND (
    $3::timestamp IS NULL OR
    m.created_at < $3::timestamp OR
    (m.created_at = $3::timestamp AND m.id < $4::uuid)
  )
ORDER BY m.created_at DESC, m.id DESC
LIMIT $2
`

type GetMessagesByChatPaginatedParams struct {
	ChatID     uuid.UUID     `json:"chat_id"`
	Limit      int32         `json:"limit"`
	CursorTime sql.NullTime  `json:"cursor_time"`
	CursorID   uuid.NullUUID `json:"cursor_id"`
}

type GetMessagesByChatPaginatedRow struct {
	ID                  uuid.UUID      `json:"id"`
	ChatID              uuid.UUID      `json:"chat_id"`
	SenderID            uuid.UUID      `json:"sender_id"`
	Content             sql.NullString `json:"content"`
	IsDeleted           bool           `json:"is_deleted"`
	IsEdited            bool           `json:"is_edited"`
	ReplyToMessageID    uuid.NullUUID  `json:"reply_to_message_id"`
	CreatedAt           time.Time      `json:"created_at"`
	UpdatedAt           time.Time      `json:"updated_at"`
	SenderUsername      string         `json:"sender_username"`
	ReplyContent        sql.NullString `json:"reply_content"`
	ReplyIsDeleted      sql.NullBool   `json:"reply_is_deleted"`
	ReplySenderID       uuid.NullUUID  `json:"reply_sender_id"`
	ReplySenderUsername sql.NullString `json:"reply_sender_username"`
}

func (q *Queries) GetMessagesByChatPaginated(ctx context.Context, arg GetMessagesByChatPaginatedParams) ([]GetMessagesByChatPaginatedRow, error) {
	rows, err := q.db.QueryContext(ctx, getMessagesByChatPaginated,
		arg.ChatID,
		arg.Limit,
		arg.CursorTime,
		arg.CursorID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMessagesByChatPaginatedRow{}
	for rows.Next() {
		var i GetMessagesByChatPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.ChatID,
			&i.SenderID,
			&i.Content,
			&i.IsDeleted,
			&i.IsEdited,
			&i.ReplyToMessageID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SenderUsername,
			&i.ReplyContent,
			&i.ReplyIsDeleted,
			&i.ReplySenderID,
			&i.ReplySenderUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
